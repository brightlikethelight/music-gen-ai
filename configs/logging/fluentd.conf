# Fluentd configuration for Music Gen AI structured logging
# Modern 2024 configuration with OpenTelemetry integration

<system>
  log_level info
  suppress_repeated_stacktrace true
  emit_error_log_interval 30s
  suppress_config_dump
  without_source
  enable_msgpack_time_support true
</system>

# Worker configuration for high throughput
<worker 0>
  # Application logs source
  <source>
    @type tail
    @id input_app_logs
    path /var/log/musicgen/app.log
    pos_file /var/log/fluentd/app.log.pos
    tag musicgen.application
    format json
    read_from_head true
    refresh_interval 5
    
    <parse>
      @type json
      time_key timestamp
      time_format %Y-%m-%dT%H:%M:%S.%LZ
      keep_time_key true
    </parse>
  </source>

  # Audit logs source
  <source>
    @type tail
    @id input_audit_logs
    path /var/log/musicgen/audit.log
    pos_file /var/log/fluentd/audit.log.pos
    tag musicgen.audit
    format json
    read_from_head true
    refresh_interval 5
    
    <parse>
      @type json
      time_key timestamp
      time_format %Y-%m-%dT%H:%M:%S.%LZ
      keep_time_key true
    </parse>
  </source>

  # Performance logs source
  <source>
    @type tail
    @id input_performance_logs
    path /var/log/musicgen/performance.log
    pos_file /var/log/fluentd/performance.log.pos
    tag musicgen.performance
    format json
    read_from_head true
    refresh_interval 5
    
    <parse>
      @type json
      time_key timestamp
      time_format %Y-%m-%dT%H:%M:%S.%LZ
      keep_time_key true
    </parse>
  </source>

  # Error logs source
  <source>
    @type tail
    @id input_error_logs
    path /var/log/musicgen/error.log
    pos_file /var/log/fluentd/error.log.pos
    tag musicgen.error
    format json
    read_from_head true
    refresh_interval 5
    
    <parse>
      @type json
      time_key timestamp
      time_format %Y-%m-%dT%H:%M:%S.%LZ
      keep_time_key true
    </parse>
  </source>

  # HTTP input for direct log shipping
  <source>
    @type http
    @id input_http
    port 9880
    bind 0.0.0.0
    tag musicgen.http
    
    <parse>
      @type json
    </parse>
    
    <transport tls>
      cert_path /etc/fluentd/ssl/cert.pem
      private_key_path /etc/fluentd/ssl/key.pem
    </transport>
  </source>

  # Forward input for Fluentd clustering
  <source>
    @type forward
    @id input_forward
    port 24224
    bind 0.0.0.0
  </source>

  # Prometheus metrics
  <source>
    @type prometheus
    @id input_prometheus
    port 24231
    bind 0.0.0.0
  </source>

  <source>
    @type prometheus_monitor
    @id input_prometheus_monitor
  </source>

  <source>
    @type prometheus_output_monitor
    @id input_prometheus_output_monitor
  </source>
</worker>

# Common filters for all log types
<filter musicgen.**>
  @type record_transformer
  @id filter_add_metadata
  enable_ruby true
  
  <record>
    service_name musicgen-api
    service_version "#{ENV['SERVICE_VERSION'] || '1.0.0'}"
    environment "#{ENV['ENVIRONMENT'] || 'production'}"
    datacenter "#{ENV['DATACENTER'] || 'unknown'}"
    hostname "#{Socket.gethostname}"
    fluentd_worker "#{worker_id}"
  </record>
</filter>

# OpenTelemetry integration
<filter musicgen.**>
  @type opentelemetry
  @id filter_opentelemetry
  
  # Add OpenTelemetry context if available
  trace_id_key trace_id
  span_id_key span_id
  trace_flags_key trace_flags
  
  # Resource attributes
  resource_attributes {
    "service.name": "musicgen-api",
    "service.version": "#{ENV['SERVICE_VERSION'] || '1.0.0'}",
    "service.namespace": "musicgen",
    "deployment.environment": "#{ENV['ENVIRONMENT'] || 'production'}"
  }
</filter>

# Application log processing
<filter musicgen.application>
  @type record_transformer
  @id filter_application_processing
  enable_ruby true
  
  <record>
    log_type application
    # Normalize log level
    level "#{record['levelname'] || record['level'] || 'INFO'}"
    logger_name "#{record['name'] || record['logger'] || 'unknown'}"
    
    # Extract correlation ID for distributed tracing
    correlation_id "#{record['correlation_id']}"
    
    # Add severity mapping for alerting
    severity "#{
      case (record['levelname'] || record['level'] || 'INFO').upcase
      when 'DEBUG' then 'low'
      when 'INFO' then 'low'
      when 'WARNING', 'WARN' then 'medium'
      when 'ERROR' then 'high'
      when 'CRITICAL', 'FATAL' then 'critical'
      else 'low'
      end
    }"
  </record>
  
  # Remove redundant fields
  remove_keys levelname,name
</filter>

# Audit log processing
<filter musicgen.audit>
  @type record_transformer
  @id filter_audit_processing
  enable_ruby true
  
  <record>
    log_type audit
    event_category security
    
    # Normalize fields for security analysis
    user_id "#{record['user_id']}"
    source_ip "#{record['ip_address']}"
    event_action "#{record['event']}"
    event_outcome "#{record['success'] ? 'success' : 'failure'}"
    
    # Add security severity
    security_severity "#{
      if record['event'] && (record['event'].include?('login') || record['event'].include?('auth'))
        record['success'] ? 'low' : 'high'
      elsif record['event'] && record['event'].include?('admin')
        'high'
      else
        'medium'
      end
    }"
  </record>
</filter>

# Performance log processing
<filter musicgen.performance>
  @type record_transformer
  @id filter_performance_processing
  enable_ruby true
  
  <record>
    log_type performance
    
    # Normalize HTTP fields
    http_method "#{record['method']}"
    http_path "#{record['path']}"
    http_status "#{record['status_code']}"
    response_time_ms "#{record['duration_ms']}"
    
    # Performance classification
    performance_tier "#{
      duration = record['duration_ms'].to_f
      if duration < 100
        'fast'
      elsif duration < 1000
        'normal'
      elsif duration < 5000
        'slow'
      else
        'very_slow'
      end
    }"
    
    # Alert flag for very slow requests
    performance_alert "#{record['duration_ms'].to_f > 5000}"
  </record>
</filter>

# Error log processing
<filter musicgen.error>
  @type record_transformer
  @id filter_error_processing
  enable_ruby true
  
  <record>
    log_type error
    event_category error
    severity critical
    alert_required true
    
    # Extract error details
    error_message "#{record['message']}"
    error_logger "#{record['name'] || record['logger']}"
  </record>
</filter>

# Elasticsearch output with proper indexing
<match musicgen.**>
  @type elasticsearch
  @id output_elasticsearch
  @log_level info
  
  # Elasticsearch connection
  host "#{ENV['ELASTICSEARCH_HOST'] || 'localhost'}"
  port "#{ENV['ELASTICSEARCH_PORT'] || '9200'}"
  scheme "#{ENV['ELASTICSEARCH_SCHEME'] || 'http'}"
  user "#{ENV['ELASTICSEARCH_USER']}" if ENV['ELASTICSEARCH_USER']
  password "#{ENV['ELASTICSEARCH_PASSWORD']}" if ENV['ELASTICSEARCH_PASSWORD']
  
  # Index configuration
  index_name musicgen-%{log_type}-%Y.%m.%d
  type_name _doc
  
  # Index lifecycle management
  ilm_policy_id musicgen-policy
  ilm_policy_overwrite true
  
  # Template configuration
  template_name musicgen
  template_file /etc/fluentd/templates/musicgen-template.json
  template_overwrite true
  
  # Performance and reliability
  reload_connections false
  reconnect_on_error true
  reload_on_failure true
  request_timeout 30s
  
  # Bulk configuration for high throughput
  bulk_message_request_threshold 1024
  bulk_message_flush_threshold 2048
  flush_interval 5s
  
  # Buffer configuration
  <buffer tag,time,log_type>
    @type file
    path /var/log/fluentd/buffer/elasticsearch
    timekey 300s
    timekey_use_utc true
    timekey_wait 10s
    chunk_limit_size 8MB
    total_limit_size 512MB
    flush_mode interval
    flush_interval 10s
    flush_thread_count 4
    retry_type exponential_backoff
    retry_wait 1s
    retry_max_interval 60s
    retry_timeout 3600s
    overflow_action drop_oldest_chunk
  </buffer>
  
  # Custom request headers
  custom_headers {
    "User-Agent": "fluentd-musicgen/1.0.0"
  }
</match>

# OpenTelemetry Collector output (if enabled)
<match musicgen.**>
  @type opentelemetry
  @id output_opentelemetry
  
  endpoint "#{ENV['OTEL_COLLECTOR_ENDPOINT']}" if ENV['OTEL_COLLECTOR_ENDPOINT']
  headers {
    "Authorization": "Bearer #{ENV['OTEL_AUTH_TOKEN']}"
  } if ENV['OTEL_AUTH_TOKEN']
  
  # Resource attributes
  add_resource_attributes {
    "service.name": "musicgen-api",
    "service.version": "#{ENV['SERVICE_VERSION'] || '1.0.0'}",
    "deployment.environment": "#{ENV['ENVIRONMENT'] || 'production'}"
  }
  
  <buffer>
    @type memory
    flush_mode immediate
  </buffer>
</match>

# Security alerts to dedicated system
<match musicgen.audit>
  @type copy
  
  <store>
    @type elasticsearch
    @id output_security_elasticsearch
    
    host "#{ENV['SECURITY_ES_HOST'] || ENV['ELASTICSEARCH_HOST'] || 'localhost'}"
    port "#{ENV['SECURITY_ES_PORT'] || ENV['ELASTICSEARCH_PORT'] || '9200'}"
    
    index_name musicgen-security-%Y.%m.%d
    type_name _doc
    
    <buffer time>
      @type file
      path /var/log/fluentd/buffer/security
      timekey 3600s
      timekey_use_utc true
      flush_mode interval
      flush_interval 30s
    </buffer>
  </store>
  
  # Send critical security events to monitoring system
  <store>
    @type webhook
    @id output_security_webhook
    
    endpoint "#{ENV['SECURITY_WEBHOOK_URL']}" if ENV['SECURITY_WEBHOOK_URL']
    http_method post
    
    <format>
      @type json
    </format>
    
    <buffer>
      @type memory
      flush_mode immediate
    </buffer>
  </store>
</match>

# Performance monitoring output
<match musicgen.performance>
  @type copy
  
  # Main elasticsearch output (handled above)
  <store>
    @type relabel
    @label @MAIN
  </store>
  
  # Metrics to Prometheus/monitoring system
  <store>
    @type prometheus
    @id output_performance_metrics
    
    <metric>
      name musicgen_http_requests_total
      type counter
      desc Total HTTP requests
      key correlation_id
      <labels>
        method ${http_method}
        status ${http_status}
        path ${http_path}
        tier ${performance_tier}
      </labels>
    </metric>
    
    <metric>
      name musicgen_http_request_duration_milliseconds
      type histogram
      desc HTTP request duration
      key response_time_ms
      buckets 10,50,100,500,1000,5000,10000
      <labels>
        method ${http_method}
        path ${http_path}
      </labels>
    </metric>
  </store>
</match>

# Error alerting
<match musicgen.error>
  @type copy
  
  # Main output
  <store>
    @type relabel
    @label @MAIN
  </store>
  
  # Alert system
  <store>
    @type webhook
    @id output_error_alerts
    
    endpoint "#{ENV['ERROR_WEBHOOK_URL']}" if ENV['ERROR_WEBHOOK_URL']
    http_method post
    
    <headers>
      Content-Type application/json
      Authorization "Bearer #{ENV['ALERT_AUTH_TOKEN']}" if ENV['ALERT_AUTH_TOKEN']
    </headers>
    
    <format>
      @type json
    </format>
    
    <buffer>
      @type memory
      flush_mode immediate
      retry_type exponential_backoff
      retry_wait 1s
      retry_max_interval 300s
      retry_forever false
      retry_max_times 3
    </buffer>
  </store>
</match>

# Backup to S3/object storage (if configured)
<match musicgen.**>
  @type s3
  @id output_s3_backup
  
  aws_key_id "#{ENV['AWS_ACCESS_KEY_ID']}" if ENV['AWS_ACCESS_KEY_ID']
  aws_sec_key "#{ENV['AWS_SECRET_ACCESS_KEY']}" if ENV['AWS_SECRET_ACCESS_KEY']
  s3_bucket "#{ENV['LOG_BACKUP_BUCKET']}" if ENV['LOG_BACKUP_BUCKET']
  s3_region "#{ENV['AWS_REGION'] || 'us-east-1'}" if ENV['LOG_BACKUP_BUCKET']
  
  path logs/musicgen/%Y/%m/%d/
  s3_object_key_format %{path}%{time_slice}_%{index}.%{file_extension}
  
  <buffer time>
    @type file
    path /var/log/fluentd/buffer/s3
    timekey 3600s
    timekey_use_utc true
    chunk_limit_size 256MB
    compress gzip
  </buffer>
  
  <format>
    @type json
  </format>
</match>

# Fallback output for debugging
<match **>
  @type file
  @id output_fallback
  path /var/log/fluentd/fallback.log
  
  <format>
    @type json
  </format>
  
  <buffer>
    @type file
    path /var/log/fluentd/buffer/fallback
    flush_mode interval
    flush_interval 30s
  </buffer>
</match>

<label @MAIN>
  <match musicgen.**>
    @type relabel
    @label @OUTPUT
  </match>
</label>

<label @OUTPUT>
  <match musicgen.**>
    @type null
  </match>
</label>